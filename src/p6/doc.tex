\chapter{Stacks}

\section{Aim}

To implement program(s) to perform stack operations using arrays and linked lists.

\section{Algorithm}

\subsection{Stack using Array}

\subsubsection
Let the $stack$ data structure contain the array $S$ of size $MAX$ and the variable $top$ to keep track of the stack header.
\begin{lstlisting}[style=myC]
record stack
{
	S[MAX];
	top;
}
\end{lstlisting}


\subsubsection{Push}
\begin{algorithmic}
	\Function{push}{$x$}
		\If{$stack.top == MAX$}
			\State \Call{error}{"Stack Overflow!}
		\EndIf
		\State $stack.top = stack.top + 1$
		\State $stack.S[stack.top] = x$	
	\EndFunction
\end{algorithmic}

\subsubsection{Pop}
\begin{algorithmic}
	\Function{pop}{}
		\If{$stack.top == 0$}
			\State \Call{error}{"Stack Underflow!}
		\EndIf
		\State $temp \gets stack.S[stack.top]$
		\State $stack.S[stack.top] = \phi$
		\State $stack.top = stack.top - 1$
		\State \Return{$temp$}
	\EndFunction
\end{algorithmic}

\subsubsection{Traverse}
\begin{algorithmic}
	\Function{traverse}{}
		\If{$stack.top == 0$}
			\State \Call{error}{"stack empty!"}
		\EndIf
		
		\State $i \gets stack.top$
		\While{$i > 0$}
			\State \Call{foo}{stack.S[i]}
			\State $i = i - 1$
		\EndWhile

	\EndFunction
\end{algorithmic}

\subsection{Stack using Linked List}
Let the $node$ data structure contain two fields,
data and the reference to the next node. Let there
also be a variable $top$ to keep track of the
first element in the stack, which is $\phi$ when the stack
is empty.

\begin{lstlisting}[style=myC]
record Node
{
	data;
	Node next;
}

record Stack
{
	Node top
}
\end{lstlisting}

\subsubsection{Push}
\begin{algorithmic}
	\Function{push}{$newNode$}
		\If{$stack.top \neq \phi$}
			\State $newNode.next = stack.top$
		\EndIf
		\State $stack.top = newNode$
	\EndFunction
\end{algorithmic}

\subsubsection{Pop}
\begin{algorithmic}
	\Function{pop}{}
		\If{$stack.top = \phi$}
			\State \Call{error}{"Stack Underflow!"}
		\EndIf
		
		\State $temp \gets stack.top$
		\State $data \gets stack.top.data$
		\State $stack.top = stack.top.next$
		\State \Call{destroy}{$temp$}
		\State \Return{$data$}
	\EndFunction
\end{algorithmic}

\subsubsection{Traverse}
\begin{algorithmic}
	\Function{traverse}{}
		\If{$stack.top = \phi$}
			\State \Call{error}{"stack empty!"}
		\EndIf
	
		\State $it \gets stack.top$
		\While{$it \neq \phi$}
			\State \Call{foo}{$it.data$}
			\State $it = it.next$
		\EndWhile
	\EndFunction
\end{algorithmic}

\section{Code}

\subsection{Stack using Array}

\subsubsection{stack-array.c}

\lstinputlisting[style=myC]{src/p6/stack-array.c}

\subsubsection{stack-array.output}

\lstinputlisting[]{src/p6/stack-array.output}

\subsection{Stack using Linked List}

\subsubsection{stack-ll.c}

\lstinputlisting[style=myC]{src/p6/stack-ll.c}

\subsubsection{stack-ll.output}

\lstinputlisting[]{src/p6/stack-ll.output}

\section{Result}
Stack operations using array and linked list were implemented successfully.